---
id: 03
title: 03. Fetch and Submit Data with GraphQL 
sidebar_label: 03. Using GraphQL
---

So far, our todo apps can insert custom name in profile page and can insert todo list. But this todo app is less helpful since we cannot track the progress of our todo items nor we can edit or delete it. Let's do some upgrade in our todo apps! While doing the upgrade, we will also get closer into Treats GraphQL. Before starting this tutorial, you may want to read more about [GraphQL][GraphQL]. __GraphQL is not mandatory in Treats__. If you want to disable it you can change it in `treats.config.js` as instructed [here][Redux Concept].

### GraphQL Configurations
Treats GraphQL configurations are under __`_graphql`__ folder. GraphQL [hooks][filesystem-hooks] contains 3 files: `link-state.js`, `uri.js`, and `config.js`. In this tutorial you may need to deploy some GraphQL service. We recommend to use [Graphcool][Graphcool] to deploy your own GraphQL service.

1. Deploy the following todo datamodel. For a quick start, let's just use [Graphcool console][Graphcool Console] to create our schema.
```
type Todo {
  id: ID! @isUnique
  status: String
  todoAction: String
}
```
You can get your graphql endpoint easily from the "endpoints" button in Graphcool. The format will be like this:
__`https://api.graph.cool/simple/v1/<key>`__

2. After get your endpoint, create __`uri.js`__ under __`_graphql`__ folder
```
/* src/_graphql/uri.js */

const uri="https://api.graph.cool/simple/v1/<your_key>";

export default uri;
```

3. Implement __`config.js`__ under __`_graphql`__ folder. This config are based on [Apollo configuration][Apollo]. Read more the Apollo configuration to create your own custom configuration
```
/* src/_graphql/config.js */

import uri from "./uri";

const customConfig = {
    queryDeduplication: true,
    link: [
        {
            type: "error",
            callback: ({ graphQLErrors, networkError }) => {
                if (graphQLErrors)
                graphQLErrors.map(({ message, locations, path }) =>
                    console.error(
                        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`
                    ));

                if (networkError) console.error(`[Network error]: ${networkError}`);
            }
        },
        {
            type: "batch-http",
            uri: uri
        }
    ]
};

export default customConfig;
```

4. Of course, we need to declare the query and some mutation for our todo page let's create __`todo`__ folder under __`_graphql`__ and create __`index.js`__, __`query.graphql`__, and __`mutation.graphql`__.
```
/* src/_graphql/index.js */

import * as todoQuery from "./query.graphql";
import * as todoMutation from "./mutation.graphql";

export { todoQuery };
export { todoMutation };
```

```
# src/_graphql/query.graphql
query GetAllTodoes {
  allTodoes {
    id,
    todoAction,
    status
  }
}
```

```
# src/_graphql/mutation.graphql
mutation CreateTodo($todoAction: String!) {
  createTodo(
    todoAction: $todoAction
    status: "not yet"
  ) {
    id,
    todoAction,
    status
  }
}

mutation DeleteTodo($id: ID!) {
  deleteTodo(
    id: $id
  ) {
    id,
    todoAction,
    status
  }
}

mutation UpdateTodo($id: ID!, $todoAction: String) {
  updateTodo(
    id: $id,
    todoAction: $todoAction
  ) {
    id,
    todoAction
  }
}

mutation UpdateTodoStatus($id: ID!, $status: String) {
  updateTodo(
    id: $id,
    status: $status
  ) {
    id,
    status
  }
}
```

5. That's the GraphQL config we need for now. Also check the [GraphQL Client][GraphQL Client] section.

### Refactoring Todo List
Our current todo list will not affected by the GraphQL configuration we just created. Now it's time to do the refactoring!

1. Back to our `todo-list` first. Since our item now have state (done or pending) we can show the item using literal string. We need to create new component for our todo items. Let's create one under `component`. You may use the component boilerplate [generator][generator]. __Note: Don't forget to write `index.js` if you are not using Treats component generator.__
```
/* src/component/todo-item/todo-item.js */

import React, { Component } from "react";

import style from "./todo-item.css";

class TodoItem extends Component {
    render () {
      const { id, todoAction, status } = this.props;

      return (  
        <div >
            <form
                onSubmit={e => {
                    e.preventDefault();
                }}
            >
                <input
                    ref={node => {
                        todo = node;
                    }}
                    defaultValue={todoAction}
                    readOnly={status === "done"}
                />
                <span>
                    <button
                        className={style.button__orange} 
                        type="submit"
                    >
                        Update Todo
                    </button>
                    <button
                        className={style.button__green}
                    >
                        Is it done?
                    </button>
                </span>
                <button 
                    className={style.button__red}
                >
                    Delete this todo
                </button>
            </form>
        </div>
      )
    }
};
  
export default TodoItem;
```

```
/* src/component/todo-item/todo-item.css */

.button__green {
    cursor: pointer;
    background-color: #42b549;
    color: #fff;
    font-weight: 700;
    margin: 10px;
}

.button__red {
    cursor: pointer;
    background-color: #d50000;
    color: #fff;
    font-weight: 700;
    margin: 10px;
}

.button__orange {
    cursor: pointer;
    background-color: #f13700;
    color: #fff;
    font-weight: 700;
    margin: 10px;
}
```

2. As we can see, the item now contains buttons for update todo item, update status, and delete it. To make our button do something, we need to connect it with mutation we defined earlier in `mutation.graphql`. To connect our components, we can use `<Mutation>` component provided by Treats's GraphQL (Apollo) client. So, our component should looks like this now
```
/* src/component/todo-item/todo-item.js */

import React, { Component } from "react";

import { Mutation } from "@treats/graphql";

import { todoMutation, todoQuery } from "../../_graphql/todo";

import style from "./todo-item.css";

class TodoItem extends Component {
    render () {
        const { id, todoAction, status } = this.props;

        return (
            <Mutation 
                mutation={todoMutation.DeleteTodo} 
                variables={{ id }} 
                refetchQueries={[{ query: todoQuery.GetAllTodoes }]}    
            >
                {(deleteTodo, { loading: deleteLoading, error: deleteError }) => (
                    <Mutation 
                        mutation={todoMutation.UpdateTodo} 
                        variables={{ id, todoAction }} 
                        refetchQueries={[{ query: todoQuery.GetAllTodoes }]}    
                    >
                        {(updateTodo, { loading: updateLoading, error: updateError }) => (
                            <Mutation 
                                mutation={todoMutation.UpdateTodoStatus} 
                                variables={{ id, status: "done" }} 
                                refetchQueries={[{ query: todoQuery.GetAllTodoes }]}    
                            >
                                {(updateTodoStatus, { loading, error }) => {
                                    let todo;

                                    return (
                                        <div >
                                            <form
                                                onSubmit={e => {
                                                    e.preventDefault();
                                                    updateTodo({ variables: { todoAction: todo.value, id } });
                                                }}
                                            >
                                                <input
                                                    ref={node => {
                                                        todo = node;
                                                    }}
                                                    defaultValue={todoAction}
                                                    readOnly={status === "done"}
                                                />
                                                {status !== "done" && (
                                                    <span>
                                                        <button
                                                            className={style.button__orange} 
                                                            type="submit"
                                                        >
                                                            Update Todo
                                                        </button>
                                                        <button
                                                            className={style.button__green} 
                                                            onClick={updateTodoStatus}
                                                        >
                                                            Is it done?
                                                        </button>
                                                    </span>
                                                )}
                                                <button 
                                                    className={style.button__red}
                                                    onClick={deleteTodo}
                                                >
                                                    Delete this todo
                                                </button>
                                            </form>
                                            {loading || (deleteLoading || updateLoading) && <p>Loading...</p>}
                                            {error || (deleteError || updateError) && <p>Error :( Please try again</p>}
                                        </div>
                                    );
                                }}
                            </Mutation>            
                        )}
                    </Mutation>
                )}
            </Mutation>
        );
    }
};
  
export default TodoItem;
```
Don't worry if it's long. It is actually easy enough to understand. If you read it carefully, we add every mutation into a single `<Mutation>` component. That's why there are 3 nested Mutation out there. Also we add some network error handler like `{loading || (deleteLoading || uploadLoading) ...}` and `{error || (deleteError || updateError) ...}`. Currently the items contain 3 mutation `updateTodo`, `updateStatus`, and `deleteTodo`

3. To make these mutation works, of course we also need to make the list stored in our GraphQL server. If it's stored in the server, then we need to fetch it first when rendering our `todo-list` component. We're going to use `<Query>` components to get our data from GraphQL server. Let's get back to our todo-list component and implement it this way.
```
/* src/component/todo-list */

import React from "react";

import { Query } from "@treats/graphql";

import { todoQuery } from "../../_graphql/todo";

import TodoItem from "../todo-item";

const TodoList = () => (
    <Query 
        query={todoQuery.GetAllTodoes}
        ssr={false}
        fetchPolicy="cache-and-network"
    >
        {
            ({ loading, error, data }) => {
                if (loading) return <p>Loading....</p>
                if (error) return <p style={{"color": "red"}}>ERROR</p>
                if (data.allTodoes) {
                    return (
                        <div>
                            {data.allTodoes.map(item => (
                                <TodoItem key={item.id} {...item} />
                            ))}
                        </div>
                    );
                }
                return (
                    <div>
                        No Data
                    </div>
                )
            }
        }
    </Query>
);
  
export default TodoList;
```
As you can see, we dont need items as a props anymore since we get it directly from GraphQL server. Also to keep our view a little bit dynamic to user, we add the `loading`, `error`, and `success` case when rendering the elements.

4. Yay! Now we can get data from GraphQL server. _Wait a minute... We get some data from server, but where the server get the data from?_. My bad! We almost forgot to send the data via our form. Let's proceed to our `todo.js` and implement it this way.
```
/* src/page/todo/todo.js */

import React from "react";
import { FormattedMessage, injectIntl } from "@treats/intl";
import Link from "@treats/component/link";
import { connect } from "@treats/redux";
import { Mutation } from "@treats/graphql";

import { todoMutation, todoQuery } from "../../_graphql/todo";

import TodoList from "../../component/todo-list";

import style from "./todo.css";

const Todo = ({ intl, name }) => (
    <div>
        <Link href="/profile" isPush>Change Name</Link>
        <br />
        <FormattedMessage
            id="todo_title" 
            values={{
                name: name,
                value2: 20
            }}
        />
        <Mutation
            mutation={todoMutation.CreateTodo}
            refetchQueries={[{ query: todoQuery.GetAllTodoes }]} 
        >
            {(addTodo, { loading, error }) => {
                let input;

                if (loading) {
                    return (<p>Loading...</p>)
                }

                if (error) {
                    return (<p>Error :( Please try again</p>)
                }

                return (
                    <div className={style.todo_form}>
                        <form onSubmit={e => {
                            e.preventDefault();
                            addTodo({ variables: { todoAction: input.value } });
                            input.value = "";
                        }}>
                            <input ref={
                                node => {
                                    input = node;
                                }
                            } />
                            <button>{intl.formatMessage({id: "submit"})}</button>
                        </form>
                    </div>
                )
            }}
        </Mutation>
        <TodoList />
        <div className={style.todo__locale_switcher_container}>
            <a
                className={`${style.todo__locale_switcher}${
                    intl.locale === "en" ? " active" : ""
                }`}
                href="/?lang=en"
            >
                English
            </a>
            <a
                className={`${style.todo__locale_switcher}${
                    intl.locale === "id" ? " active" : ""
                }`}
                href="/?lang=id"
            >
                Indonesian
            </a>
        </div>
    </div>
)

const mapStateToProps = state => ({
    name: state.profile.name
})

export default connect(mapStateToProps)(injectIntl(Todo));
```

Here, we don't need state anymore since we fetch input value directly using ref. So, we will change the component into functional component.

5. All's done! Let's check our todo in GraphQL now! Pretty cool, isn't it? With some touch of css, now you can make this todo apps into more beatiful page. Keep exploring!

[GraphQL]: https://graphql.org/learn/
[filesystem-hooks]: ../api-reference/filesystem-hooks.html
[Graphcool]: https://www.graph.cool/docs/quickstart
[Graphcool Console]: https://console.graph.cool/login
[Apollo]: https://www.apollographql.com/docs/react/
[GraphQL Client]: ../main-concept/graphql-client.html
[generator]: ../main-concept/generator.html
